
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Η εργασία γίνεται compile με make all στον φάκελο Exercise1 και τρέχει με την εντολή ./hp_main

Περιγραφή υλοποίησης:

    - Η εργασία διεκπεραιώθηκε σε γλώσσα C.

    - Η εργασία στο σύνολο της έγινε με δια ζώσης συνεργασία των μελών και δεν αποδίδονται εύσημα σε συγκεκριμένο άτομο για συγκεκριμένο τμήμα
    κώδικα.

    - Το πρώτο block κάθε αρχείου περιέχει μια δομή με τα μεταδεδομένα του αρχείου δηλαδή το id του τελευταίου block και το μέγιστο αριθμό 
    εγγραφών που περιέχει κάθε block (HP_info). Επιπλέον, αυτό καθώς και κάθε block εγγραφών, περιέχει μια δομή μεταδεδομένων που αφορούν το 
    συγκεκριμένο block (HP_block_info). Στο block μεταδεδομένων του αρχείου (πρώτο block) η δομή που αφορά τα δεδομένα του block έχει οριστεί
    για λόγους ομοιομορφίας και δεν έχει κάποια πρακτική χρησιμότητα καθώς το block δεν περιέχει εγγραφές.

    - Τα block που περιέχουν εγγραφές έχουν την εξής δομή:
    Οι εγγραφές εισάγονται στην αρχή του block (σειριακά) ενώ τα μεταδεδομένα του block αποθηκεύονται στο τέλος του.

    - Στο αρχείο hp_main.c το οποίο χρησιμοποιήθηκε για να ελεγχθεί η ορθότητα του κώδικα έχουν προστεθεί κάποιες κλήσεις της συνάρτησης 
    HP_GetAllEntries για πιο εκτεταμένο και ακριβή έλεγχο.

Σχόλια:

    - Το metadata block έχει id = 0.

    - Τα blocks με records έχουν id >= 1, με το κάθε id να είναι μεγαλύτερο κάτα 1 από αυτό του προηγούμενου record.

    - Στο κάθε block μπορούν να αποθηκευτούν μέχρι 6 εγγραφές. 
    Αυτό συμβαίνει γιατί γνωρίζουμε πως για την αποθήκευση char χρειάζεται 1 byte και για ints 4 bytes. Έτσι, με δεδομένα τα πεδία της δομής
    record, συμπεραίνουμε οτι η κάθε εγγραφή θα χρειαστεί: 15*1 + 1*4 + 15*1 + 20*1 + 20*1 = 74 bytes. Εφόσον το κάθε block έχει μέγεθος 512 
    bytes μπορούν σ' αυτο ν' αποθηκευτούν εγγραφές ίσες με: lower_bound(512/74) = lower_bound(6,918) = 6 εγγραφές. Με την παραπάνω υλοποίηση
    οι εγγραφές σε κάθε block δεσμεύουν το πολυ 74 * 6 = 444 bytes, αφήνοντας χώρο για τα metadata ίσο με 512 - 444 = 68 bytes.

    - Σε κάποια σημεία του κώδικα γίνεται χρήση της εντολής: HP_block_info* block_info =  data + BF_BLOCK_SIZE - sizeof(*block_info) -1; 
    για να πάρουμε ένα δείκτη στο σημείο του block όπου ξεκινάνε τα μεταδεδομένα που αφορούν το block.
    Η λογική της εντολής αυτής είναι η εξης:
        ~ Το data είναι ένας δείκτης στην αρχή του block.
        ~ Το BF_BLOCK_SIZE είναι σταθερά 512, και η προσθήκη του στο data μας "πάει" στην αρχή του επόμενου block.
        ~ Η αφαίρεση του 1 έχει ως αποτέλεσμα να "επιστρέψουμε" στην τελευταία θέση του block που εξετάζουμε.
        ~ Τέλος η αφαίρεση του sizeof(*block_info), δηλαδή η αφαίρεση του μεγέθους των metadata, βεβαιώνει ότι ο δείκτης block_info δείχνει 
        στην αρχή των μεταδεδομένων του εν λόγω block (επειδή τα metadata βρίσκονται στο τέλος του block).

    - Στην HP_GetAllEntries επιστρέφουμε τον συνολικό αριθμό των blocks -1 (το metadata block) καθώς αυτό δεν το ψάξαμε.

    - Κατά τη δημιουργία του κώδικα, για να επαληθεύσουμε οτι οι εγγραφές τοποθετούνται στα σωστά blocks χρησιμοποιήσαμε κάποιες εντολές printf
    τις οποίες αφήσαμε σε comments, σε περίπτωση που η υπάρξη τους διευκολύνει τη διόρθωση.

Σύμβαση:

    - Έγινε η σύμβαση στην HP_InsertEntry ότι το block που αφορά τα μεταδεδομένα θα γίνεται unpin μόλις τελειώσει η εισαγωγή διότι 
    παρατηρήθηκε στους ελέγχους οτι η έλλειψη του παραπάνω φαινόταν να δημιουργεί κάποιο πρόβλημα.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
